'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _backo = require('backo');

var _backo2 = _interopRequireDefault(_backo);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _immutable = require('immutable');

var _lodash = require('lodash.identity');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.includes');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.isfunction');

var _lodash6 = _interopRequireDefault(_lodash5);

var _actions = require('../actions');

var _actionTypes = require('../constants/action-types');

var actionTypes = _interopRequireWildcard(_actionTypes);

var _httpMethods = require('../constants/http-methods');

var httpMethods = _interopRequireWildcard(_httpMethods);

var _statusCodes = require('../constants/status-codes');

var statusCodes = _interopRequireWildcard(_statusCodes);

var _queryKey3 = require('../lib/query-key');

var _update2 = require('../lib/update');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultConfig = {
  backoff: {
    maxAttempts: 5,
    minDuration: 300,
    maxDuration: 5000
  },
  retryableStatusCodes: [statusCodes.UNKNOWN, // normally means a failed connection
  statusCodes.REQUEST_TIMEOUT, statusCodes.TOO_MANY_REQUESTS, // hopefully backoff stops this getting worse
  statusCodes.SERVICE_UNAVAILABLE, statusCodes.GATEWAY_TIMEOUT]
};

var getPendingQueries = function getPendingQueries(queries) {
  return queries.filter(function (query) {
    return query.get('isPending');
  });
};

var keyIn = function keyIn(keys) {
  var keySet = (0, _immutable.Set)(keys);
  return function (v, k) {
    return keySet.has(k);
  };
};

var resOk = function resOk(status) {
  return Math.floor(status / 100) === 2;
};

var queryMiddlewareAdvanced = function queryMiddlewareAdvanced(networkInterface) {
  return function (queriesSelector, entitiesSelector, resultsSelector) {
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultConfig;

    return function (_ref) {
      var dispatch = _ref.dispatch,
          getState = _ref.getState;
      return function (next) {
        return function (action) {
          var returnValue = void 0;

          switch (action.type) {
            case actionTypes.REQUEST_ASYNC:
              {
                var url = action.url,
                    body = action.body,
                    force = action.force,
                    retry = action.retry,
                    _action$transform = action.transform,
                    transform = _action$transform === undefined ? _lodash2.default : _action$transform,
                    _action$transformResu = action.transformResult,
                    transformResult = _action$transformResu === undefined ? _lodash2.default : _action$transformResu,
                    update = action.update,
                    updateResult = action.updateResult,
                    _action$options = action.options,
                    options = _action$options === undefined ? {} : _action$options,
                    meta = action.meta;


                (0, _invariant2.default)(!!url, 'Missing required `url` field in action handler');
                (0, _invariant2.default)(!!update, 'Missing required `update` field in action handler');

                var queryKey = (0, _queryKey3.getQueryKey)(action);

                var state = getState();
                var queries = queriesSelector(state);

                var queriesState = queries.get(queryKey, new _immutable.Map());
                var isPending = queriesState.get('isPending');
                var status = queriesState.get('status');
                var hasSucceeded = status >= 200 && status < 300;

                if (force || queriesState.isEmpty() || retry && !isPending && !hasSucceeded) {
                  returnValue = new Promise(function (resolve) {
                    var start = new Date();
                    var _options$method = options.method,
                        method = _options$method === undefined ? httpMethods.GET : _options$method;

                    var attempts = 0;
                    var backoff = new _backo2.default({
                      min: config.backoff.minDuration,
                      max: config.backoff.maxDuration
                    });

                    var attemptRequest = function attemptRequest() {
                      var networkHandler = networkInterface(url, method, {
                        body: body,
                        headers: options.headers,
                        credentials: options.credentials
                      });

                      dispatch((0, _actions.requestStart)({
                        body: body,
                        meta: meta,
                        networkHandler: networkHandler,
                        queryKey: queryKey,
                        url: url
                      }));

                      attempts += 1;

                      networkHandler.execute(function (err, status, responseBody, responseText, responseHeaders) {
                        if ((0, _lodash4.default)(config.retryableStatusCodes, status) && attempts < config.backoff.maxAttempts) {
                          // TODO take into account Retry-After header if 503
                          setTimeout(attemptRequest, backoff.duration());
                          return;
                        }

                        var end = new Date();
                        var duration = end - start;
                        var transformed = void 0;
                        var newEntities = void 0;
                        var transformedResult = void 0;
                        var newResults = void 0;

                        if (action.unstable_preDispatchCallback) {
                          action.unstable_preDispatchCallback();
                        }

                        if (err || !resOk(status)) {
                          dispatch((0, _actions.requestFailure)({
                            body: body,
                            duration: duration,
                            meta: meta,
                            queryKey: queryKey,
                            responseBody: responseBody,
                            responseHeaders: responseHeaders,
                            status: status,
                            responseText: responseText,
                            url: url
                          }));

                          resolve({
                            body: responseBody,
                            duration: duration,
                            status: status,
                            text: responseText,
                            headers: responseHeaders
                          });
                        } else {
                          var callbackState = getState();
                          var entities = entitiesSelector(callbackState);
                          var results = resultsSelector(callbackState);
                          transformed = (0, _immutable.fromJS)(transform(responseBody, responseText));
                          newEntities = (0, _update2.updateEntities)(update, entities, transformed);
                          transformedResult = (0, _immutable.fromJS)(transformResult(responseBody, responseText));
                          newResults = (0, _update2.updateResults)(updateResult, results, transformedResult);

                          dispatch((0, _actions.requestSuccess)({
                            body: body,
                            duration: duration,
                            meta: meta,
                            entities: newEntities,
                            results: newResults,
                            queryKey: queryKey,
                            responseBody: responseBody,
                            responseHeaders: responseHeaders,
                            status: status,
                            responseText: responseText,
                            url: url
                          }));

                          resolve({
                            body: responseBody,
                            duration: duration,
                            status: status,
                            text: responseText,
                            transformed: transformed,
                            entities: newEntities,
                            transformedResult: transformedResult,
                            results: newResults,
                            headers: responseHeaders
                          });
                        }
                      });
                    };

                    attemptRequest();
                  });
                }

                break;
              }
            case actionTypes.MUTATE_ASYNC:
              {
                var _url = action.url,
                    _action$transform2 = action.transform,
                    _transform = _action$transform2 === undefined ? _lodash2.default : _action$transform2,
                    _action$transformResu2 = action.transformResult,
                    _transformResult = _action$transformResu2 === undefined ? _lodash2.default : _action$transformResu2,
                    _update = action.update,
                    _updateResult = action.updateResult,
                    rollback = action.rollback,
                    _body = action.body,
                    optimisticUpdate = action.optimisticUpdate,
                    _action$options2 = action.options,
                    _options = _action$options2 === undefined ? {} : _action$options2,
                    _meta = action.meta;

                (0, _invariant2.default)(!!_url, 'Missing required `url` field in action handler');

                var initialState = getState();
                var initialEntities = entitiesSelector(initialState);
                var optimisticEntities = void 0;

                if (optimisticUpdate) {
                  optimisticEntities = (0, _update2.optimisticUpdateEntities)(optimisticUpdate, initialEntities);
                }

                var _queryKey = (0, _queryKey3.getQueryKey)(action);

                returnValue = new Promise(function (resolve) {
                  var start = new Date();
                  var _options$method2 = _options.method,
                      method = _options$method2 === undefined ? httpMethods.POST : _options$method2;


                  var networkHandler = networkInterface(_url, method, {
                    body: _body,
                    headers: _options.headers,
                    credentials: _options.credentials,
                    multipart: _options.multipart
                  });

                  // Note: only the entities that are included in `optimisticUpdate` will be passed along in the
                  // `mutateStart` action as `optimisticEntities`
                  dispatch((0, _actions.mutateStart)({
                    body: _body,
                    meta: _meta,
                    networkHandler: networkHandler,
                    optimisticEntities: optimisticEntities,
                    queryKey: _queryKey,
                    url: _url
                  }));

                  networkHandler.execute(function (err, status, responseBody, responseText, responseHeaders) {
                    var end = new Date();
                    var duration = end - start;
                    var state = getState();
                    var entities = entitiesSelector(state);
                    var results = resultsSelector(state);

                    var transformed = void 0;
                    var newEntities = void 0;
                    var transformedResult = void 0;
                    var newResults = void 0;

                    if (err || !resOk(status)) {
                      var rolledBackEntities = void 0;

                      if (optimisticUpdate) {
                        rolledBackEntities = (0, _update2.rollbackEntities)(rollback, initialEntities.filter(keyIn(Object.keys(optimisticEntities.toObject()))), entities.filter(keyIn(Object.keys(optimisticEntities.toObject()))));
                      }

                      dispatch((0, _actions.mutateFailure)({
                        body: _body,
                        duration: duration,
                        meta: _meta,
                        queryKey: _queryKey,
                        responseBody: responseBody,
                        responseHeaders: responseHeaders,
                        status: status,
                        responseText: responseText,
                        rolledBackEntities: rolledBackEntities,
                        url: _url
                      }));

                      resolve({
                        body: responseBody,
                        duration: duration,
                        status: status,
                        text: responseText,
                        headers: responseHeaders
                      });
                    } else {
                      transformed = (0, _immutable.fromJS)(_transform(responseBody, responseText));
                      newEntities = (0, _update2.updateEntities)(_update, entities, transformed);
                      transformedResult = (0, _immutable.fromJS)(_transformResult(responseBody, responseText));
                      newResults = (0, _update2.updateResults)(_updateResult, results, transformedResult);

                      dispatch((0, _actions.mutateSuccess)({
                        url: _url,
                        body: _body,
                        duration: duration,
                        status: status,
                        entities: newEntities,
                        results: newResults,
                        queryKey: _queryKey,
                        responseBody: responseBody,
                        responseText: responseText,
                        responseHeaders: responseHeaders,
                        meta: _meta
                      }));

                      resolve({
                        body: responseBody,
                        duration: duration,
                        status: status,
                        text: responseText,
                        transformed: transformed,
                        entities: newEntities,
                        transformedResult: transformedResult,
                        results: newResults,
                        headers: responseHeaders
                      });
                    }
                  });
                });

                break;
              }
            case actionTypes.CANCEL_QUERY:
              {
                var _queryKey2 = action.queryKey;

                (0, _invariant2.default)(!!_queryKey2, 'Missing required `queryKey` field in action handler');

                var _state = getState();
                var _queries = queriesSelector(_state);
                var pendingQueries = getPendingQueries(_queries);

                if (pendingQueries.has(_queryKey2)) {
                  pendingQueries.getIn([_queryKey2, 'networkHandler', 'abort'])();
                  returnValue = next(action);
                } else {
                  console.warn('Trying to cancel a request that is not in flight: ', _queryKey2);
                  returnValue = null;
                }

                break;
              }
            case actionTypes.RESET:
              {
                var _state2 = getState();
                var _queries2 = queriesSelector(_state2);
                var _pendingQueries = getPendingQueries(_queries2);

                _pendingQueries.forEach(function (query) {
                  return query.getIn(['networkHandler', 'abort'])();
                });
                returnValue = next(action);

                break;
              }
            case actionTypes.REQUEST_SUCCESS:
              {
                var successCallback = action.successCallback;


                if (successCallback && (0, _lodash6.default)(successCallback)) {
                  successCallback(action.responseBody);
                }

                returnValue = next(action);

                break;
              }
            case actionTypes.REQUEST_FAILURE:
              {
                var errorCallback = action.errorCallback;


                if (errorCallback && (0, _lodash6.default)(errorCallback)) {
                  errorCallback(action.responseBody);
                }

                returnValue = next(action);

                break;
              }
            default:
              {
                returnValue = next(action);
              }
          }

          return returnValue;
        };
      };
    };
  };
};

exports.default = queryMiddlewareAdvanced;